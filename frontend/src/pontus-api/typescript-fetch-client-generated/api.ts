/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Simple Inventory API
 * This is a simple API
 *
 * OpenAPI spec version: 1.0.0
 * Contact: you@your-company.com
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from 'url';
import * as isomorphicFetch from 'isomorphic-fetch';
import { Configuration } from './configuration';

const BASE_PATH =
  'https://virtserver.swaggerhub.com/PVPMARTINS_1/PontusBackend2/1.0.0'.replace(
    /\/+$/,
    '',
  );

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ',',
  ssv: ' ',
  tsv: '\t',
  pipes: '|',
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string;
  options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration;

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = isomorphicFetch,
  ) {
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name: 'RequiredError';
  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

/**
 *
 * @export
 * @interface AgGridInputFilters
 */
export interface AgGridInputFilters {
  /**
   *
   * @type {string}
   * @memberof AgGridInputFilters
   */
  colId?: string;
  /**
   *
   * @type {string}
   * @memberof AgGridInputFilters
   */
  filterType?: string;
  /**
   *
   * @type {string}
   * @memberof AgGridInputFilters
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof AgGridInputFilters
   */
  filter?: string;
}
/**
 *
 * @export
 * @interface AgGridInputSearch
 */
export interface AgGridInputSearch {
  /**
   *
   * @type {string}
   * @memberof AgGridInputSearch
   */
  searchStr?: string;
  /**
   *
   * @type {boolean}
   * @memberof AgGridInputSearch
   */
  searchExact?: boolean;
  /**
   *
   * @type {Array<AgGridInputSearchCols>}
   * @memberof AgGridInputSearch
   */
  cols?: Array<AgGridInputSearchCols>;
  /**
   *
   * @type {AgGridInputSearchExtraSearch}
   * @memberof AgGridInputSearch
   */
  extraSearch?: AgGridInputSearchExtraSearch;
}
/**
 *
 * @export
 * @interface AgGridInputSearchCols
 */
export interface AgGridInputSearchCols {
  /**
   *
   * @type {string}
   * @memberof AgGridInputSearchCols
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof AgGridInputSearchCols
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof AgGridInputSearchCols
   */
  field?: string;
  /**
   *
   * @type {boolean}
   * @memberof AgGridInputSearchCols
   */
  sortable?: boolean;
  /**
   *
   * @type {string}
   * @memberof AgGridInputSearchCols
   */
  headerName?: string;
  /**
   *
   * @type {boolean}
   * @memberof AgGridInputSearchCols
   */
  filter?: boolean;
}
/**
 *
 * @export
 * @interface AgGridInputSearchExtraSearch
 */
export interface AgGridInputSearchExtraSearch {
  /**
   *
   * @type {string}
   * @memberof AgGridInputSearchExtraSearch
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof AgGridInputSearchExtraSearch
   */
  value?: string;
}
/**
 *
 * @export
 * @interface AgGridReadReq
 */
export interface AgGridReadReq {
  /**
   *
   * @type {AgGridInputSearch}
   * @memberof AgGridReadReq
   */
  search?: AgGridInputSearch;
  /**
   *
   * @type {Array<AgGridInputSearchCols>}
   * @memberof AgGridReadReq
   */
  cols?: Array<AgGridInputSearchCols>;
  /**
   *
   * @type {Array<AgGridInputFilters>}
   * @memberof AgGridReadReq
   */
  filters?: Array<AgGridInputFilters>;
  /**
   *
   * @type {string}
   * @memberof AgGridReadReq
   */
  dataType?: string;
  /**
   *
   * @type {number}
   * @memberof AgGridReadReq
   */
  from?: number;
  /**
   *
   * @type {number}
   * @memberof AgGridReadReq
   */
  to?: number;
  /**
   *
   * @type {string}
   * @memberof AgGridReadReq
   */
  sortCol?: string;
  /**
   *
   * @type {string}
   * @memberof AgGridReadReq
   */
  sortDir?: string;
}
/**
 *
 * @export
 * @interface AgGridReadRes
 */
export interface AgGridReadRes {
  /**
   *
   * @type {string}
   * @memberof AgGridReadRes
   */
  type?: string;
  /**
   *
   * @type {number}
   * @memberof AgGridReadRes
   */
  from?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof AgGridReadRes
   */
  records?: Array<string>;
  /**
   *
   * @type {number}
   * @memberof AgGridReadRes
   */
  to?: number;
  /**
   *
   * @type {number}
   * @memberof AgGridReadRes
   */
  totalAvailable?: number;
}
/**
 *
 * @export
 * @interface AuthCreateBody
 */
export interface AuthCreateBody {
  /**
   *
   * @type {string}
   * @memberof AuthCreateBody
   */
  dashboardId?: string;
  /**
   *
   * @type {DashboardgroupauthcreateAuthGroups}
   * @memberof AuthCreateBody
   */
  authGroups?: DashboardgroupauthcreateAuthGroups;
}
/**
 *
 * @export
 * @interface AuthDeleteBody
 */
export interface AuthDeleteBody {
  /**
   *
   * @type {string}
   * @memberof AuthDeleteBody
   */
  dashboardId?: string;
  /**
   *
   * @type {AuthGroups}
   * @memberof AuthDeleteBody
   */
  authGroups?: AuthGroups;
}
/**
 *
 * @export
 * @interface AuthGroupRef
 */
export interface AuthGroupRef {
  /**
   * Unique identifier of the group
   * @type {string}
   * @memberof AuthGroupRef
   */
  groupId?: string;
  /**
   * Name of the group
   * @type {string}
   * @memberof AuthGroupRef
   */
  name?: string;
}
/**
 *
 * @export
 * @interface AuthGroups
 */
export interface AuthGroups {
  /**
   *
   * @type {Array<string>}
   * @memberof AuthGroups
   */
  create?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof AuthGroups
   */
  read?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof AuthGroups
   */
  update?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof AuthGroups
   */
  _delete?: Array<string>;
}
/**
 *
 * @export
 * @interface AuthReadBody
 */
export interface AuthReadBody {
  /**
   *
   * @type {string}
   * @memberof AuthReadBody
   */
  dashboardId?: string;
}
/**
 *
 * @export
 * @interface AuthUpdateBody
 */
export interface AuthUpdateBody {
  /**
   *
   * @type {string}
   * @memberof AuthUpdateBody
   */
  dashboardId?: string;
  /**
   *
   * @type {AuthGroups}
   * @memberof AuthUpdateBody
   */
  authGroups?: AuthGroups;
}
/**
 *
 * @export
 * @interface BaseModelRef
 */
export interface BaseModelRef {
  /**
   * Unique identifier
   * @type {string}
   * @memberof BaseModelRef
   */
  id: string;
}
/**
 *
 * @export
 * @interface Dashboard
 */
export interface Dashboard {
  /**
   *
   * @type {string}
   * @memberof Dashboard
   */
  owner?: string;
  /**
   *
   * @type {string}
   * @memberof Dashboard
   */
  folder?: string;
  /**
   *
   * @type {string}
   * @memberof Dashboard
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof Dashboard
   */
  id?: string;
}
/**
 *
 * @export
 * @interface DashboardAuthGroup
 */
export interface DashboardAuthGroup {
  /**
   * Unique identifier of the dashboard
   * @type {string}
   * @memberof DashboardAuthGroup
   */
  dashboardId?: string;
  /**
   *
   * @type {string}
   * @memberof DashboardAuthGroup
   */
  dashboardName?: string;
  /**
   *
   * @type {AuthGroups}
   * @memberof DashboardAuthGroup
   */
  authGroups?: AuthGroups;
}
/**
 *
 * @export
 * @interface DashboardCreateReq
 */
export interface DashboardCreateReq extends DashboardRef {}
/**
 *
 * @export
 * @interface DashboardCreateRes
 */
export interface DashboardCreateRes extends DashboardRef {
  /**
   * Unique identifier
   * @type {string}
   * @memberof DashboardCreateRes
   */
  id: string;
}
/**
 *
 * @export
 * @interface DashboardDeleteReq
 */
export interface DashboardDeleteReq extends BaseModelRef {}
/**
 *
 * @export
 * @interface DashboardReadReq
 */
export interface DashboardReadReq extends BaseModelRef {}
/**
 *
 * @export
 * @interface DashboardReadRes
 */
export interface DashboardReadRes extends DashboardRef {
  /**
   * Unique identifier
   * @type {string}
   * @memberof DashboardReadRes
   */
  id: string;
}
/**
 *
 * @export
 * @interface DashboardRef
 */
export interface DashboardRef {
  /**
   * Name of the dashboard
   * @type {string}
   * @memberof DashboardRef
   */
  name?: string;
  /**
   * Folder where the dashboard belongs
   * @type {string}
   * @memberof DashboardRef
   */
  folder?: string;
  /**
   * Owner of the dashboard
   * @type {string}
   * @memberof DashboardRef
   */
  owner?: string;
  /**
   * JSON containing all the dashboard state
   * @type {any}
   * @memberof DashboardRef
   */
  state?: any;
}
/**
 *
 * @export
 * @interface DashboardUpdateBody
 */
export interface DashboardUpdateBody extends DashboardUpdateReq {}
/**
 *
 * @export
 * @interface DashboardUpdateReq
 */
export interface DashboardUpdateReq extends BaseModelRef {
  /**
   * Name of the dashboard
   * @type {string}
   * @memberof DashboardUpdateReq
   */
  name?: string;
  /**
   * Folder where the dashboard belongs
   * @type {string}
   * @memberof DashboardUpdateReq
   */
  folder?: string;
  /**
   * Owner of the dashboard
   * @type {string}
   * @memberof DashboardUpdateReq
   */
  owner?: string;
  /**
   * JSON containing all the dashboard state
   * @type {any}
   * @memberof DashboardUpdateReq
   */
  state?: any;
}
/**
 *
 * @export
 * @interface DashboardUpdateRes
 */
export interface DashboardUpdateRes extends BaseModelRef {
  /**
   * Name of the dashboard
   * @type {string}
   * @memberof DashboardUpdateRes
   */
  name?: string;
  /**
   * Folder where the dashboard belongs
   * @type {string}
   * @memberof DashboardUpdateRes
   */
  folder?: string;
  /**
   * Owner of the dashboard
   * @type {string}
   * @memberof DashboardUpdateRes
   */
  owner?: string;
  /**
   * JSON containing all the dashboard state
   * @type {any}
   * @memberof DashboardUpdateRes
   */
  state?: any;
}
/**
 *
 * @export
 * @interface DashboardgroupauthcreateAuthGroups
 */
export interface DashboardgroupauthcreateAuthGroups {
  /**
   *
   * @type {Array<string>}
   * @memberof DashboardgroupauthcreateAuthGroups
   */
  create?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof DashboardgroupauthcreateAuthGroups
   */
  read?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof DashboardgroupauthcreateAuthGroups
   */
  update?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof DashboardgroupauthcreateAuthGroups
   */
  _delete?: Array<string>;
}
/**
 *
 * @export
 * @interface DashboardsReadReq
 */
export interface DashboardsReadReq extends ReadPaginationFilter {}
/**
 *
 * @export
 * @interface DashboardsReadRes
 */
export interface DashboardsReadRes {
  /**
   *
   * @type {number}
   * @memberof DashboardsReadRes
   */
  totalDashboards?: number;
  /**
   *
   * @type {Array<Dashboard>}
   * @memberof DashboardsReadRes
   */
  dashboards?: Array<Dashboard>;
}
/**
 *
 * @export
 * @interface DeleteTableRow
 */
export interface DeleteTableRow {
  /**
   *
   * @type {string}
   * @memberof DeleteTableRow
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof DeleteTableRow
   */
  rowId?: string;
}
/**
 *
 * @export
 * @interface DeleteUser
 */
export interface DeleteUser {
  /**
   *
   * @type {string}
   * @memberof DeleteUser
   */
  userId?: string;
}
/**
 *
 * @export
 * @interface GroupCreateReq
 */
export interface GroupCreateReq {
  /**
   * Name of the group
   * @type {string}
   * @memberof GroupCreateReq
   */
  name?: string;
  /**
   * Parent groups of the group (optional)
   * @type {Array<string>}
   * @memberof GroupCreateReq
   */
  parents?: Array<string>;
  /**
   * Symlinks associated with the group (optional)
   * @type {Array<string>}
   * @memberof GroupCreateReq
   */
  symlinks?: Array<string>;
}
/**
 *
 * @export
 * @interface GroupDeleteReq
 */
export interface GroupDeleteReq {
  /**
   *
   * @type {string}
   * @memberof GroupDeleteReq
   */
  groupId?: string;
}
/**
 *
 * @export
 * @interface GroupReadBody
 */
export interface GroupReadBody {
  /**
   *
   * @type {string}
   * @memberof GroupReadBody
   */
  groupId?: string;
}
/**
 *
 * @export
 * @interface GroupUpdateReq
 */
export interface GroupUpdateReq {
  /**
   * ID of the group to update
   * @type {string}
   * @memberof GroupUpdateReq
   */
  groupId?: string;
  /**
   * Updated name of the group
   * @type {string}
   * @memberof GroupUpdateReq
   */
  name?: string;
  /**
   * Updated parent groups of the group (optional)
   * @type {Array<string>}
   * @memberof GroupUpdateReq
   */
  parents?: Array<string>;
  /**
   * Updated symlinks associated with the group (optional)
   * @type {Array<string>}
   * @memberof GroupUpdateReq
   */
  symlinks?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
  /**
   *
   * @type {number}
   * @memberof InlineResponse2001
   */
  totalGroups?: number;
  /**
   *
   * @type {Array<AuthGroupRef>}
   * @memberof InlineResponse2001
   */
  authGroups?: Array<AuthGroupRef>;
}
/**
 *
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
  /**
   *
   * @type {number}
   * @memberof InlineResponse2002
   */
  totalUsers?: number;
  /**
   *
   * @type {Array<User>}
   * @memberof InlineResponse2002
   */
  users?: Array<User>;
}
/**
 *
 * @export
 * @interface MenuCreateReq
 */
export interface MenuCreateReq extends MenuDirectoryTreeRef {}

/**
 * @export
 * @namespace MenuCreateReq
 */
export namespace MenuCreateReq {}
/**
 *
 * @export
 * @interface MenuCreateRes
 */
export interface MenuCreateRes extends MenuDirectoryTreeRef {
  /**
   * Unique identifier
   * @type {string}
   * @memberof MenuCreateRes
   */
  id: string;
}

/**
 * @export
 * @namespace MenuCreateRes
 */
export namespace MenuCreateRes {}
/**
 *
 * @export
 * @interface MenuDeleteReq
 */
export interface MenuDeleteReq extends BaseModelRef {}
/**
 *
 * @export
 * @interface MenuDirectoryTreeRef
 */
export interface MenuDirectoryTreeRef {
  /**
   *
   * @type {string}
   * @memberof MenuDirectoryTreeRef
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof MenuDirectoryTreeRef
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof MenuDirectoryTreeRef
   */
  kind?: MenuDirectoryTreeRef.KindEnum;
  /**
   *
   * @type {string}
   * @memberof MenuDirectoryTreeRef
   */
  path?: string;
  /**
   *
   * @type {Array<MenuDirectoryTreeRef>}
   * @memberof MenuDirectoryTreeRef
   */
  children?: Array<MenuDirectoryTreeRef>;
}

/**
 * @export
 * @namespace MenuDirectoryTreeRef
 */
export namespace MenuDirectoryTreeRef {
  /**
   * @export
   * @enum {string}
   */
  export enum KindEnum {
    Folder = <any>'folder',
    File = <any>'file',
  }
}
/**
 *
 * @export
 * @interface MenuReadReq
 */
export interface MenuReadReq {
  /**
   *
   * @type {string}
   * @memberof MenuReadReq
   */
  path: string;
}
/**
 *
 * @export
 * @interface MenuReadRes
 */
export interface MenuReadRes extends MenuDirectoryTreeRef {
  /**
   * Unique identifier
   * @type {string}
   * @memberof MenuReadRes
   */
  id: string;
}

/**
 * @export
 * @namespace MenuReadRes
 */
export namespace MenuReadRes {}
/**
 *
 * @export
 * @interface MenuUpdateReq
 */
export interface MenuUpdateReq extends MenuDirectoryTreeRef {
  /**
   * Unique identifier
   * @type {string}
   * @memberof MenuUpdateReq
   */
  id: string;
}

/**
 * @export
 * @namespace MenuUpdateReq
 */
export namespace MenuUpdateReq {}
/**
 *
 * @export
 * @interface MenuUpdateRes
 */
export interface MenuUpdateRes extends MenuDirectoryTreeRef {
  /**
   * Unique identifier
   * @type {string}
   * @memberof MenuUpdateRes
   */
  id: string;
}

/**
 * @export
 * @namespace MenuUpdateRes
 */
export namespace MenuUpdateRes {}
/**
 *
 * @export
 * @interface NewTableRow
 */
export interface NewTableRow {
  /**
   *
   * @type {string}
   * @memberof NewTableRow
   */
  id?: string;
  /**
   *
   * @type {NewTableRowCols}
   * @memberof NewTableRow
   */
  cols?: NewTableRowCols;
}
/**
 *
 * @export
 * @interface NewTableRowCols
 */
export interface NewTableRowCols {
  /**
   *
   * @type {string}
   * @memberof NewTableRowCols
   */
  colId?: string;
}
/**
 *
 * @export
 * @interface NewUser
 */
export interface NewUser {
  /**
   * Name of the user
   * @type {string}
   * @memberof NewUser
   */
  name?: string;
  /**
   * IDs of the groups the user belongs to
   * @type {Array<string>}
   * @memberof NewUser
   */
  authGroups?: Array<string>;
}
/**
 *
 * @export
 * @interface ReadPaginationFilter
 */
export interface ReadPaginationFilter {
  /**
   *
   * @type {number}
   * @memberof ReadPaginationFilter
   */
  from?: number;
  /**
   *
   * @type {number}
   * @memberof ReadPaginationFilter
   */
  to?: number;
  /**
   *
   * @type {{ [key: string]: ReadPaginationFilterFilters; }}
   * @memberof ReadPaginationFilter
   */
  filters?: { [key: string]: ReadPaginationFilterFilters };
}
/**
 *
 * @export
 * @interface ReadPaginationFilterFilters
 */
export interface ReadPaginationFilterFilters {
  /**
   *
   * @type {string}
   * @memberof ReadPaginationFilterFilters
   */
  sort?: string;
  /**
   *
   * @type {string | number}
   * @memberof ReadPaginationFilterFilters
   */
  filter?: string | number;
  /**
   *
   * @type {string}
   * @memberof ReadPaginationFilterFilters
   */
  type?: string;
  /**
   *
   * @type {Date | string}
   * @memberof ReadPaginationFilterFilters
   */
  dateFrom?: Date | string;
  /**
   *
   * @type {Date | string}
   * @memberof ReadPaginationFilterFilters
   */
  dateTo?: Date | string;
  /**
   *
   * @type {string | number}
   * @memberof ReadPaginationFilterFilters
   */
  filterTo?: string | number;
  /**
   *
   * @type {ReadPaginationFilterFiltersColIdCondition}
   * @memberof ReadPaginationFilterFilters
   */
  condition1?: ReadPaginationFilterFiltersColIdCondition;
  /**
   *
   * @type {ReadPaginationFilterFiltersColIdCondition}
   * @memberof ReadPaginationFilterFilters
   */
  condition2?: ReadPaginationFilterFiltersColIdCondition;
  /**
   *
   * @type {string}
   * @memberof ReadPaginationFilterFilters
   */
  filterType?: string;
  /**
   *
   * @type {string}
   * @memberof ReadPaginationFilterFilters
   */
  operator?: string;
}
/**
 *
 * @export
 * @interface ReadPaginationFilterFiltersColIdCondition
 */
export interface ReadPaginationFilterFiltersColIdCondition {
  /**
   *
   * @type {Date | string}
   * @memberof ReadPaginationFilterFiltersColIdCondition
   */
  dateFrom?: Date | string;
  /**
   *
   * @type {Date | string}
   * @memberof ReadPaginationFilterFiltersColIdCondition
   */
  dateTo?: Date | string;
  /**
   *
   * @type {string | number}
   * @memberof ReadPaginationFilterFiltersColIdCondition
   */
  filter?: string | number;
  /**
   *
   * @type {string | number}
   * @memberof ReadPaginationFilterFiltersColIdCondition
   */
  filterTo?: string | number;
  /**
   *
   * @type {string}
   * @memberof ReadPaginationFilterFiltersColIdCondition
   */
  filterType?: string;
  /**
   *
   * @type {string}
   * @memberof ReadPaginationFilterFiltersColIdCondition
   */
  type?: string;
}
/**
 *
 * @export
 * @interface TableColumnRef
 */
export interface TableColumnRef {
  /**
   * Unique identifier of the table column
   * @type {string}
   * @memberof TableColumnRef
   */
  id?: string;
  /**
   * Name of the table column
   * @type {string}
   * @memberof TableColumnRef
   */
  name?: string;
  /**
   * Field name of the table column
   * @type {string}
   * @memberof TableColumnRef
   */
  field?: string;
  /**
   * Indicates if the table column is sortable
   * @type {boolean}
   * @memberof TableColumnRef
   */
  sortable?: boolean;
  /**
   * Header name of the table column
   * @type {string}
   * @memberof TableColumnRef
   */
  headerName?: string;
  /**
   * Indicates if the table column is filterable
   * @type {boolean}
   * @memberof TableColumnRef
   */
  filter?: boolean;
  /**
   * Indicates the kind of column input
   * @type {string}
   * @memberof TableColumnRef
   */
  kind?: TableColumnRef.KindEnum;
}

/**
 * @export
 * @namespace TableColumnRef
 */
export namespace TableColumnRef {
  /**
   * @export
   * @enum {string}
   */
  export enum KindEnum {
    Checkboxes = <any>'checkboxes',
    Selectbox = <any>'selectbox',
    Text = <any>'text',
    Number = <any>'number',
    Phone = <any>'phone',
    Zipcode = <any>'zipcode',
    Email = <any>'email',
    Zipcode_7 = <any>'zipcode',
  }
}
/**
 *
 * @export
 * @interface TableCreateReq
 */
export interface TableCreateReq {
  /**
   * Name of the table
   * @type {string}
   * @memberof TableCreateReq
   */
  name?: string;
  /**
   * Table columns to be associated with the table during creation
   * @type {Array<TableColumnRef>}
   * @memberof TableCreateReq
   */
  cols?: Array<TableColumnRef>;
}
/**
 *
 * @export
 * @interface TableCreateRes
 */
export interface TableCreateRes extends BaseModelRef {
  /**
   * Name of the table
   * @type {string}
   * @memberof TableCreateRes
   */
  name?: string;
  /**
   * Table columns associated with the table
   * @type {Array<TableColumnRef>}
   * @memberof TableCreateRes
   */
  cols?: Array<TableColumnRef>;
}
/**
 *
 * @export
 * @interface TableDeleteReq
 */
export interface TableDeleteReq extends BaseModelRef {}
/**
 *
 * @export
 * @interface TableReadReq
 */
export interface TableReadReq extends BaseModelRef {}
/**
 *
 * @export
 * @interface TableReadRes
 */
export interface TableReadRes extends BaseModelRef {
  /**
   * Name of the table
   * @type {string}
   * @memberof TableReadRes
   */
  name?: string;
  /**
   * Table columns associated with the table
   * @type {Array<TableColumnRef>}
   * @memberof TableReadRes
   */
  cols?: Array<TableColumnRef>;
}
/**
 *
 * @export
 * @interface TableRef
 */
export interface TableRef {
  /**
   * Name of the table
   * @type {string}
   * @memberof TableRef
   */
  name?: string;
  /**
   * Table columns associated with the table
   * @type {Array<TableColumnRef>}
   * @memberof TableRef
   */
  cols?: Array<TableColumnRef>;
}
/**
 *
 * @export
 * @interface TableUpdateReq
 */
export interface TableUpdateReq extends BaseModelRef {
  /**
   * Name of the table
   * @type {string}
   * @memberof TableUpdateReq
   */
  name?: string;
  /**
   * Table columns associated with the table
   * @type {Array<TableColumnRef>}
   * @memberof TableUpdateReq
   */
  cols?: Array<TableColumnRef>;
}
/**
 *
 * @export
 * @interface TablesReadRes
 */
export interface TablesReadRes {
  /**
   *
   * @type {number}
   * @memberof TablesReadRes
   */
  totalTables?: number;
  /**
   * Table columns associated with the table
   * @type {Array<BaseModelRef & TableRef>}
   * @memberof TablesReadRes
   */
  tables?: Array<BaseModelRef & TableRef>;
}
/**
 *
 * @export
 * @interface UpdateTableRow
 */
export interface UpdateTableRow {
  /**
   *
   * @type {string}
   * @memberof UpdateTableRow
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateTableRow
   */
  rowId?: string;
  /**
   *
   * @type {NewTableRowCols}
   * @memberof UpdateTableRow
   */
  cols?: NewTableRowCols;
}
/**
 *
 * @export
 * @interface UpdateUser
 */
export interface UpdateUser {
  /**
   * ID of the user to update
   * @type {string}
   * @memberof UpdateUser
   */
  userId?: string;
  /**
   * Updated name of the user
   * @type {string}
   * @memberof UpdateUser
   */
  name?: string;
  /**
   * Updated IDs of the groups the user belongs to
   * @type {Array<string>}
   * @memberof UpdateUser
   */
  authGroups?: Array<string>;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   * Unique identifier of the user
   * @type {string}
   * @memberof User
   */
  userId?: string;
  /**
   * Name of the user
   * @type {string}
   * @memberof User
   */
  name?: string;
  /**
   * IDs of the groups the user belongs to
   * @type {Array<string>}
   * @memberof User
   */
  authGroups?: Array<string>;
}
/**
 *
 * @export
 * @interface UserReadBody
 */
export interface UserReadBody {
  /**
   *
   * @type {string}
   * @memberof UserReadBody
   */
  userId?: string;
}
/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Create a new group with a name, parents, and symlinks
     * @summary Create a new group
     * @param {GroupCreateReq} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authGroupCreatePOST(body: GroupCreateReq, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling authGroupCreatePOST.',
        );
      }
      const localVarPath = `/auth/group/create`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'GroupCreateReq' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a group by ID
     * @summary Delete a group
     * @param {GroupDeleteReq} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authGroupDeletePOST(body: GroupDeleteReq, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling authGroupDeletePOST.',
        );
      }
      const localVarPath = `/auth/group/delete`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'GroupDeleteReq' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve group by id
     * @summary Get group by ID
     * @param {GroupReadBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authGroupReadPOST(body: GroupReadBody, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling authGroupReadPOST.',
        );
      }
      const localVarPath = `/auth/group/read`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'GroupReadBody' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update group details by ID
     * @summary Update group by ID
     * @param {GroupUpdateReq} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authGroupUpdatePOST(body: GroupUpdateReq, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling authGroupUpdatePOST.',
        );
      }
      const localVarPath = `/auth/group/update`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'GroupUpdateReq' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve all groups (nodes that Aggrid is using a new pagination filter model)
     * @summary Get all groups
     * @param {ReadPaginationFilter} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authGroupsReadPOST(
      body: ReadPaginationFilter,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling authGroupsReadPOST.',
        );
      }
      const localVarPath = `/auth/groups/read`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'ReadPaginationFilter' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new user with a name and associated groups
     * @summary Create a new user
     * @param {NewUser} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUserCreatePOST(body: NewUser, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling authUserCreatePOST.',
        );
      }
      const localVarPath = `/auth/user/create`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'NewUser' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a user by ID
     * @summary Delete a user
     * @param {DeleteUser} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUserDeletePOST(body: DeleteUser, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling authUserDeletePOST.',
        );
      }
      const localVarPath = `/auth/user/delete`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'DeleteUser' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve user by ID
     * @summary Get user by ID
     * @param {UserReadBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUserReadPOST(body: UserReadBody, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling authUserReadPOST.',
        );
      }
      const localVarPath = `/auth/user/read`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'UserReadBody' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update user details by ID
     * @summary Update user by ID
     * @param {UpdateUser} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUserUpdatePOST(body: UpdateUser, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling authUserUpdatePOST.',
        );
      }
      const localVarPath = `/auth/user/update`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'UpdateUser' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve all users
     * @summary Get all users
     * @param {ReadPaginationFilter} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersReadPOST(
      body: ReadPaginationFilter,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling authUsersReadPOST.',
        );
      }
      const localVarPath = `/auth/users/read`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'ReadPaginationFilter' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new dashboard with properties, auth group, folder, and owner
     * @summary Create a new dashboard
     * @param {DashboardCreateReq} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dashboardCreatePOST(
      body: DashboardCreateReq,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling dashboardCreatePOST.',
        );
      }
      const localVarPath = `/dashboard/create`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'DashboardCreateReq' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a dashboard by ID
     * @summary Delete a dashboard
     * @param {DashboardDeleteReq} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dashboardDeletePOST(
      body: DashboardDeleteReq,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling dashboardDeletePOST.',
        );
      }
      const localVarPath = `/dashboard/delete`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'DashboardDeleteReq' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new dashboard state with name and state information
     * @summary Create a new dashboard state
     * @param {AuthCreateBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dashboardGroupAuthCreatePOST(
      body: AuthCreateBody,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling dashboardGroupAuthCreatePOST.',
        );
      }
      const localVarPath = `/dashboard/group/auth/create`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'AuthCreateBody' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new dashboard state with name and state information
     * @summary Delete group from dashboard
     * @param {AuthDeleteBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dashboardGroupAuthDeletePOST(
      body: AuthDeleteBody,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling dashboardGroupAuthDeletePOST.',
        );
      }
      const localVarPath = `/dashboard/group/auth/delete`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'AuthDeleteBody' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new dashboard state with name and state information
     * @summary Create a new dashboard state
     * @param {AuthReadBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dashboardGroupAuthReadPOST(
      body: AuthReadBody,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling dashboardGroupAuthReadPOST.',
        );
      }
      const localVarPath = `/dashboard/group/auth/read`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'AuthReadBody' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new dashboard state with name and state information
     * @summary Create a new dashboard state
     * @param {AuthUpdateBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dashboardGroupAuthUpdatePOST(
      body: AuthUpdateBody,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling dashboardGroupAuthUpdatePOST.',
        );
      }
      const localVarPath = `/dashboard/group/auth/update`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'AuthUpdateBody' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve dashboard by id
     * @summary Get dashboard by id
     * @param {DashboardReadReq} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dashboardReadPOST(body: DashboardReadReq, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling dashboardReadPOST.',
        );
      }
      const localVarPath = `/dashboard/read`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'DashboardReadReq' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update dashboard properties, auth group, folder, and owner by ID
     * @summary Update dashboard by ID
     * @param {DashboardUpdateBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dashboardUpdatePOST(
      body: DashboardUpdateBody,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling dashboardUpdatePOST.',
        );
      }
      const localVarPath = `/dashboard/update`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'DashboardUpdateBody' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve all dashboards with pagination and search
     * @summary Get all dashboards
     * @param {DashboardsReadReq} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dashboardsReadPOST(body: DashboardsReadReq, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling dashboardsReadPOST.',
        );
      }
      const localVarPath = `/dashboards/read`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'DashboardsReadReq' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {AgGridReadReq} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTableData(body?: AgGridReadReq, options: any = {}): FetchArgs {
      const localVarPath = `/table/data/read`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'AgGridReadReq' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {MenuCreateReq} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    menuCreatePOST(body?: MenuCreateReq, options: any = {}): FetchArgs {
      const localVarPath = `/menu/create`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'MenuCreateReq' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {MenuDeleteReq} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    menuDeletePOST(body?: MenuDeleteReq, options: any = {}): FetchArgs {
      const localVarPath = `/menu/delete`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'MenuDeleteReq' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {MenuReadReq} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    menuReadPOST(body?: MenuReadReq, options: any = {}): FetchArgs {
      const localVarPath = `/menu/read`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'MenuReadReq' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {MenuUpdateReq} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    menuUpdatePOST(body?: MenuUpdateReq, options: any = {}): FetchArgs {
      const localVarPath = `/menu/update`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'MenuUpdateReq' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new table with properties and associated columns
     * @summary Create a new table
     * @param {TableCreateReq} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tableCreatePOST(body?: TableCreateReq, options: any = {}): FetchArgs {
      const localVarPath = `/table/create`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'TableCreateReq' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new row data, by using key/value pair for each column.
     * @summary Create a new row
     * @param {NewTableRow} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tableDataCreatePOST(body: NewTableRow, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling tableDataCreatePOST.',
        );
      }
      const localVarPath = `/table/data/create`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'NewTableRow' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update a row data, by using key/value pair for each column.
     * @summary Update a row
     * @param {DeleteTableRow} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tableDataDeletePOST(body: DeleteTableRow, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling tableDataDeletePOST.',
        );
      }
      const localVarPath = `/table/data/delete`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'DeleteTableRow' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update a row data, by using key/value pair for each column.
     * @summary Update a row
     * @param {UpdateTableRow} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tableDataUpdatePOST(body: UpdateTableRow, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling tableDataUpdatePOST.',
        );
      }
      const localVarPath = `/table/data/update`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'UpdateTableRow' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a table by ID
     * @summary Delete a table
     * @param {TableDeleteReq} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tableDeletePOST(body: TableDeleteReq, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling tableDeletePOST.',
        );
      }
      const localVarPath = `/table/delete`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'TableDeleteReq' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get table by id
     * @summary Get table by id
     * @param {TableReadReq} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tableReadPOST(body: TableReadReq, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling tableReadPOST.',
        );
      }
      const localVarPath = `/table/read`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'TableReadReq' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update table properties and associated columns by ID
     * @summary Update table by ID
     * @param {TableUpdateReq} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tableUpdatePOST(body: TableUpdateReq, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling tableUpdatePOST.',
        );
      }
      const localVarPath = `/table/update`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'TableUpdateReq' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve all tables with pagination and search
     * @summary Get all tables
     * @param {ReadPaginationFilter} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tablesReadPOST(body: ReadPaginationFilter, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling tablesReadPOST.',
        );
      }
      const localVarPath = `/tables/read`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'ReadPaginationFilter' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Create a new group with a name, parents, and symlinks
     * @summary Create a new group
     * @param {GroupCreateReq} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authGroupCreatePOST(
      body: GroupCreateReq,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AuthGroupRef> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).authGroupCreatePOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Delete a group by ID
     * @summary Delete a group
     * @param {GroupDeleteReq} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authGroupDeletePOST(
      body: GroupDeleteReq,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).authGroupDeletePOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieve group by id
     * @summary Get group by ID
     * @param {GroupReadBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authGroupReadPOST(
      body: GroupReadBody,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AuthGroupRef> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).authGroupReadPOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Update group details by ID
     * @summary Update group by ID
     * @param {GroupUpdateReq} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authGroupUpdatePOST(
      body: GroupUpdateReq,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).authGroupUpdatePOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieve all groups (nodes that Aggrid is using a new pagination filter model)
     * @summary Get all groups
     * @param {ReadPaginationFilter} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authGroupsReadPOST(
      body: ReadPaginationFilter,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).authGroupsReadPOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Create a new user with a name and associated groups
     * @summary Create a new user
     * @param {NewUser} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUserCreatePOST(
      body: NewUser,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).authUserCreatePOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Delete a user by ID
     * @summary Delete a user
     * @param {DeleteUser} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUserDeletePOST(
      body: DeleteUser,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).authUserDeletePOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieve user by ID
     * @summary Get user by ID
     * @param {UserReadBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUserReadPOST(
      body: UserReadBody,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).authUserReadPOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Update user details by ID
     * @summary Update user by ID
     * @param {UpdateUser} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUserUpdatePOST(
      body: UpdateUser,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).authUserUpdatePOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieve all users
     * @summary Get all users
     * @param {ReadPaginationFilter} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersReadPOST(
      body: ReadPaginationFilter,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).authUsersReadPOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Create a new dashboard with properties, auth group, folder, and owner
     * @summary Create a new dashboard
     * @param {DashboardCreateReq} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dashboardCreatePOST(
      body: DashboardCreateReq,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<DashboardCreateRes> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).dashboardCreatePOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Delete a dashboard by ID
     * @summary Delete a dashboard
     * @param {DashboardDeleteReq} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dashboardDeletePOST(
      body: DashboardDeleteReq,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).dashboardDeletePOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Create a new dashboard state with name and state information
     * @summary Create a new dashboard state
     * @param {AuthCreateBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dashboardGroupAuthCreatePOST(
      body: AuthCreateBody,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<DashboardAuthGroup> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).dashboardGroupAuthCreatePOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Create a new dashboard state with name and state information
     * @summary Delete group from dashboard
     * @param {AuthDeleteBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dashboardGroupAuthDeletePOST(
      body: AuthDeleteBody,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AuthDeleteBody> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).dashboardGroupAuthDeletePOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Create a new dashboard state with name and state information
     * @summary Create a new dashboard state
     * @param {AuthReadBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dashboardGroupAuthReadPOST(
      body: AuthReadBody,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<DashboardAuthGroup> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).dashboardGroupAuthReadPOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Create a new dashboard state with name and state information
     * @summary Create a new dashboard state
     * @param {AuthUpdateBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dashboardGroupAuthUpdatePOST(
      body: AuthUpdateBody,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<DashboardAuthGroup> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).dashboardGroupAuthUpdatePOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieve dashboard by id
     * @summary Get dashboard by id
     * @param {DashboardReadReq} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dashboardReadPOST(
      body: DashboardReadReq,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<DashboardReadRes> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).dashboardReadPOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Update dashboard properties, auth group, folder, and owner by ID
     * @summary Update dashboard by ID
     * @param {DashboardUpdateBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dashboardUpdatePOST(
      body: DashboardUpdateBody,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<DashboardUpdateRes> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).dashboardUpdatePOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieve all dashboards with pagination and search
     * @summary Get all dashboards
     * @param {DashboardsReadReq} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dashboardsReadPOST(
      body: DashboardsReadReq,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<DashboardsReadRes> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).dashboardsReadPOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {AgGridReadReq} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTableData(
      body?: AgGridReadReq,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AgGridReadRes> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).getTableData(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {MenuCreateReq} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    menuCreatePOST(
      body?: MenuCreateReq,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MenuCreateRes> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).menuCreatePOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {MenuDeleteReq} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    menuDeletePOST(
      body?: MenuDeleteReq,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).menuDeletePOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {MenuReadReq} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    menuReadPOST(
      body?: MenuReadReq,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MenuReadRes> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).menuReadPOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {MenuUpdateReq} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    menuUpdatePOST(
      body?: MenuUpdateReq,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MenuUpdateRes> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).menuUpdatePOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Create a new table with properties and associated columns
     * @summary Create a new table
     * @param {TableCreateReq} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tableCreatePOST(
      body?: TableCreateReq,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<TableCreateRes> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).tableCreatePOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Create a new row data, by using key/value pair for each column.
     * @summary Create a new row
     * @param {NewTableRow} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tableDataCreatePOST(
      body: NewTableRow,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).tableDataCreatePOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Update a row data, by using key/value pair for each column.
     * @summary Update a row
     * @param {DeleteTableRow} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tableDataDeletePOST(
      body: DeleteTableRow,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).tableDataDeletePOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Update a row data, by using key/value pair for each column.
     * @summary Update a row
     * @param {UpdateTableRow} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tableDataUpdatePOST(
      body: UpdateTableRow,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).tableDataUpdatePOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Delete a table by ID
     * @summary Delete a table
     * @param {TableDeleteReq} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tableDeletePOST(
      body: TableDeleteReq,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).tableDeletePOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get table by id
     * @summary Get table by id
     * @param {TableReadReq} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tableReadPOST(
      body: TableReadReq,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<TableReadRes> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).tableReadPOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Update table properties and associated columns by ID
     * @summary Update table by ID
     * @param {TableUpdateReq} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tableUpdatePOST(
      body: TableUpdateReq,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).tableUpdatePOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Retrieve all tables with pagination and search
     * @summary Get all tables
     * @param {ReadPaginationFilter} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tablesReadPOST(
      body: ReadPaginationFilter,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<TablesReadRes> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).tablesReadPOST(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Create a new group with a name, parents, and symlinks
     * @summary Create a new group
     * @param {GroupCreateReq} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authGroupCreatePOST(body: GroupCreateReq, options?: any) {
      return DefaultApiFp(configuration).authGroupCreatePOST(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Delete a group by ID
     * @summary Delete a group
     * @param {GroupDeleteReq} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authGroupDeletePOST(body: GroupDeleteReq, options?: any) {
      return DefaultApiFp(configuration).authGroupDeletePOST(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Retrieve group by id
     * @summary Get group by ID
     * @param {GroupReadBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authGroupReadPOST(body: GroupReadBody, options?: any) {
      return DefaultApiFp(configuration).authGroupReadPOST(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Update group details by ID
     * @summary Update group by ID
     * @param {GroupUpdateReq} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authGroupUpdatePOST(body: GroupUpdateReq, options?: any) {
      return DefaultApiFp(configuration).authGroupUpdatePOST(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Retrieve all groups (nodes that Aggrid is using a new pagination filter model)
     * @summary Get all groups
     * @param {ReadPaginationFilter} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authGroupsReadPOST(body: ReadPaginationFilter, options?: any) {
      return DefaultApiFp(configuration).authGroupsReadPOST(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Create a new user with a name and associated groups
     * @summary Create a new user
     * @param {NewUser} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUserCreatePOST(body: NewUser, options?: any) {
      return DefaultApiFp(configuration).authUserCreatePOST(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Delete a user by ID
     * @summary Delete a user
     * @param {DeleteUser} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUserDeletePOST(body: DeleteUser, options?: any) {
      return DefaultApiFp(configuration).authUserDeletePOST(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Retrieve user by ID
     * @summary Get user by ID
     * @param {UserReadBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUserReadPOST(body: UserReadBody, options?: any) {
      return DefaultApiFp(configuration).authUserReadPOST(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Update user details by ID
     * @summary Update user by ID
     * @param {UpdateUser} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUserUpdatePOST(body: UpdateUser, options?: any) {
      return DefaultApiFp(configuration).authUserUpdatePOST(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Retrieve all users
     * @summary Get all users
     * @param {ReadPaginationFilter} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersReadPOST(body: ReadPaginationFilter, options?: any) {
      return DefaultApiFp(configuration).authUsersReadPOST(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Create a new dashboard with properties, auth group, folder, and owner
     * @summary Create a new dashboard
     * @param {DashboardCreateReq} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dashboardCreatePOST(body: DashboardCreateReq, options?: any) {
      return DefaultApiFp(configuration).dashboardCreatePOST(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Delete a dashboard by ID
     * @summary Delete a dashboard
     * @param {DashboardDeleteReq} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dashboardDeletePOST(body: DashboardDeleteReq, options?: any) {
      return DefaultApiFp(configuration).dashboardDeletePOST(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Create a new dashboard state with name and state information
     * @summary Create a new dashboard state
     * @param {AuthCreateBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dashboardGroupAuthCreatePOST(body: AuthCreateBody, options?: any) {
      return DefaultApiFp(configuration).dashboardGroupAuthCreatePOST(
        body,
        options,
      )(fetch, basePath);
    },
    /**
     * Create a new dashboard state with name and state information
     * @summary Delete group from dashboard
     * @param {AuthDeleteBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dashboardGroupAuthDeletePOST(body: AuthDeleteBody, options?: any) {
      return DefaultApiFp(configuration).dashboardGroupAuthDeletePOST(
        body,
        options,
      )(fetch, basePath);
    },
    /**
     * Create a new dashboard state with name and state information
     * @summary Create a new dashboard state
     * @param {AuthReadBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dashboardGroupAuthReadPOST(body: AuthReadBody, options?: any) {
      return DefaultApiFp(configuration).dashboardGroupAuthReadPOST(
        body,
        options,
      )(fetch, basePath);
    },
    /**
     * Create a new dashboard state with name and state information
     * @summary Create a new dashboard state
     * @param {AuthUpdateBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dashboardGroupAuthUpdatePOST(body: AuthUpdateBody, options?: any) {
      return DefaultApiFp(configuration).dashboardGroupAuthUpdatePOST(
        body,
        options,
      )(fetch, basePath);
    },
    /**
     * Retrieve dashboard by id
     * @summary Get dashboard by id
     * @param {DashboardReadReq} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dashboardReadPOST(body: DashboardReadReq, options?: any) {
      return DefaultApiFp(configuration).dashboardReadPOST(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Update dashboard properties, auth group, folder, and owner by ID
     * @summary Update dashboard by ID
     * @param {DashboardUpdateBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dashboardUpdatePOST(body: DashboardUpdateBody, options?: any) {
      return DefaultApiFp(configuration).dashboardUpdatePOST(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Retrieve all dashboards with pagination and search
     * @summary Get all dashboards
     * @param {DashboardsReadReq} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dashboardsReadPOST(body: DashboardsReadReq, options?: any) {
      return DefaultApiFp(configuration).dashboardsReadPOST(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @param {AgGridReadReq} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTableData(body?: AgGridReadReq, options?: any) {
      return DefaultApiFp(configuration).getTableData(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @param {MenuCreateReq} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    menuCreatePOST(body?: MenuCreateReq, options?: any) {
      return DefaultApiFp(configuration).menuCreatePOST(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @param {MenuDeleteReq} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    menuDeletePOST(body?: MenuDeleteReq, options?: any) {
      return DefaultApiFp(configuration).menuDeletePOST(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @param {MenuReadReq} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    menuReadPOST(body?: MenuReadReq, options?: any) {
      return DefaultApiFp(configuration).menuReadPOST(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @param {MenuUpdateReq} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    menuUpdatePOST(body?: MenuUpdateReq, options?: any) {
      return DefaultApiFp(configuration).menuUpdatePOST(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Create a new table with properties and associated columns
     * @summary Create a new table
     * @param {TableCreateReq} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tableCreatePOST(body?: TableCreateReq, options?: any) {
      return DefaultApiFp(configuration).tableCreatePOST(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Create a new row data, by using key/value pair for each column.
     * @summary Create a new row
     * @param {NewTableRow} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tableDataCreatePOST(body: NewTableRow, options?: any) {
      return DefaultApiFp(configuration).tableDataCreatePOST(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Update a row data, by using key/value pair for each column.
     * @summary Update a row
     * @param {DeleteTableRow} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tableDataDeletePOST(body: DeleteTableRow, options?: any) {
      return DefaultApiFp(configuration).tableDataDeletePOST(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Update a row data, by using key/value pair for each column.
     * @summary Update a row
     * @param {UpdateTableRow} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tableDataUpdatePOST(body: UpdateTableRow, options?: any) {
      return DefaultApiFp(configuration).tableDataUpdatePOST(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Delete a table by ID
     * @summary Delete a table
     * @param {TableDeleteReq} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tableDeletePOST(body: TableDeleteReq, options?: any) {
      return DefaultApiFp(configuration).tableDeletePOST(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Get table by id
     * @summary Get table by id
     * @param {TableReadReq} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tableReadPOST(body: TableReadReq, options?: any) {
      return DefaultApiFp(configuration).tableReadPOST(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Update table properties and associated columns by ID
     * @summary Update table by ID
     * @param {TableUpdateReq} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tableUpdatePOST(body: TableUpdateReq, options?: any) {
      return DefaultApiFp(configuration).tableUpdatePOST(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     * Retrieve all tables with pagination and search
     * @summary Get all tables
     * @param {ReadPaginationFilter} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tablesReadPOST(body: ReadPaginationFilter, options?: any) {
      return DefaultApiFp(configuration).tablesReadPOST(body, options)(
        fetch,
        basePath,
      );
    },
  };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   * Create a new group with a name, parents, and symlinks
   * @summary Create a new group
   * @param {GroupCreateReq} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public authGroupCreatePOST(body: GroupCreateReq, options?: any) {
    return DefaultApiFp(this.configuration).authGroupCreatePOST(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Delete a group by ID
   * @summary Delete a group
   * @param {GroupDeleteReq} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public authGroupDeletePOST(body: GroupDeleteReq, options?: any) {
    return DefaultApiFp(this.configuration).authGroupDeletePOST(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Retrieve group by id
   * @summary Get group by ID
   * @param {GroupReadBody} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public authGroupReadPOST(body: GroupReadBody, options?: any) {
    return DefaultApiFp(this.configuration).authGroupReadPOST(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Update group details by ID
   * @summary Update group by ID
   * @param {GroupUpdateReq} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public authGroupUpdatePOST(body: GroupUpdateReq, options?: any) {
    return DefaultApiFp(this.configuration).authGroupUpdatePOST(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Retrieve all groups (nodes that Aggrid is using a new pagination filter model)
   * @summary Get all groups
   * @param {ReadPaginationFilter} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public authGroupsReadPOST(body: ReadPaginationFilter, options?: any) {
    return DefaultApiFp(this.configuration).authGroupsReadPOST(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Create a new user with a name and associated groups
   * @summary Create a new user
   * @param {NewUser} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public authUserCreatePOST(body: NewUser, options?: any) {
    return DefaultApiFp(this.configuration).authUserCreatePOST(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Delete a user by ID
   * @summary Delete a user
   * @param {DeleteUser} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public authUserDeletePOST(body: DeleteUser, options?: any) {
    return DefaultApiFp(this.configuration).authUserDeletePOST(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Retrieve user by ID
   * @summary Get user by ID
   * @param {UserReadBody} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public authUserReadPOST(body: UserReadBody, options?: any) {
    return DefaultApiFp(this.configuration).authUserReadPOST(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Update user details by ID
   * @summary Update user by ID
   * @param {UpdateUser} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public authUserUpdatePOST(body: UpdateUser, options?: any) {
    return DefaultApiFp(this.configuration).authUserUpdatePOST(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Retrieve all users
   * @summary Get all users
   * @param {ReadPaginationFilter} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public authUsersReadPOST(body: ReadPaginationFilter, options?: any) {
    return DefaultApiFp(this.configuration).authUsersReadPOST(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Create a new dashboard with properties, auth group, folder, and owner
   * @summary Create a new dashboard
   * @param {DashboardCreateReq} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public dashboardCreatePOST(body: DashboardCreateReq, options?: any) {
    return DefaultApiFp(this.configuration).dashboardCreatePOST(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Delete a dashboard by ID
   * @summary Delete a dashboard
   * @param {DashboardDeleteReq} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public dashboardDeletePOST(body: DashboardDeleteReq, options?: any) {
    return DefaultApiFp(this.configuration).dashboardDeletePOST(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Create a new dashboard state with name and state information
   * @summary Create a new dashboard state
   * @param {AuthCreateBody} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public dashboardGroupAuthCreatePOST(body: AuthCreateBody, options?: any) {
    return DefaultApiFp(this.configuration).dashboardGroupAuthCreatePOST(
      body,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Create a new dashboard state with name and state information
   * @summary Delete group from dashboard
   * @param {AuthDeleteBody} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public dashboardGroupAuthDeletePOST(body: AuthDeleteBody, options?: any) {
    return DefaultApiFp(this.configuration).dashboardGroupAuthDeletePOST(
      body,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Create a new dashboard state with name and state information
   * @summary Create a new dashboard state
   * @param {AuthReadBody} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public dashboardGroupAuthReadPOST(body: AuthReadBody, options?: any) {
    return DefaultApiFp(this.configuration).dashboardGroupAuthReadPOST(
      body,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Create a new dashboard state with name and state information
   * @summary Create a new dashboard state
   * @param {AuthUpdateBody} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public dashboardGroupAuthUpdatePOST(body: AuthUpdateBody, options?: any) {
    return DefaultApiFp(this.configuration).dashboardGroupAuthUpdatePOST(
      body,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Retrieve dashboard by id
   * @summary Get dashboard by id
   * @param {DashboardReadReq} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public dashboardReadPOST(body: DashboardReadReq, options?: any) {
    return DefaultApiFp(this.configuration).dashboardReadPOST(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Update dashboard properties, auth group, folder, and owner by ID
   * @summary Update dashboard by ID
   * @param {DashboardUpdateBody} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public dashboardUpdatePOST(body: DashboardUpdateBody, options?: any) {
    return DefaultApiFp(this.configuration).dashboardUpdatePOST(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Retrieve all dashboards with pagination and search
   * @summary Get all dashboards
   * @param {DashboardsReadReq} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public dashboardsReadPOST(body: DashboardsReadReq, options?: any) {
    return DefaultApiFp(this.configuration).dashboardsReadPOST(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @param {AgGridReadReq} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getTableData(body?: AgGridReadReq, options?: any) {
    return DefaultApiFp(this.configuration).getTableData(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @param {MenuCreateReq} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public menuCreatePOST(body?: MenuCreateReq, options?: any) {
    return DefaultApiFp(this.configuration).menuCreatePOST(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @param {MenuDeleteReq} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public menuDeletePOST(body?: MenuDeleteReq, options?: any) {
    return DefaultApiFp(this.configuration).menuDeletePOST(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @param {MenuReadReq} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public menuReadPOST(body?: MenuReadReq, options?: any) {
    return DefaultApiFp(this.configuration).menuReadPOST(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @param {MenuUpdateReq} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public menuUpdatePOST(body?: MenuUpdateReq, options?: any) {
    return DefaultApiFp(this.configuration).menuUpdatePOST(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Create a new table with properties and associated columns
   * @summary Create a new table
   * @param {TableCreateReq} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public tableCreatePOST(body?: TableCreateReq, options?: any) {
    return DefaultApiFp(this.configuration).tableCreatePOST(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Create a new row data, by using key/value pair for each column.
   * @summary Create a new row
   * @param {NewTableRow} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public tableDataCreatePOST(body: NewTableRow, options?: any) {
    return DefaultApiFp(this.configuration).tableDataCreatePOST(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Update a row data, by using key/value pair for each column.
   * @summary Update a row
   * @param {DeleteTableRow} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public tableDataDeletePOST(body: DeleteTableRow, options?: any) {
    return DefaultApiFp(this.configuration).tableDataDeletePOST(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Update a row data, by using key/value pair for each column.
   * @summary Update a row
   * @param {UpdateTableRow} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public tableDataUpdatePOST(body: UpdateTableRow, options?: any) {
    return DefaultApiFp(this.configuration).tableDataUpdatePOST(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Delete a table by ID
   * @summary Delete a table
   * @param {TableDeleteReq} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public tableDeletePOST(body: TableDeleteReq, options?: any) {
    return DefaultApiFp(this.configuration).tableDeletePOST(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Get table by id
   * @summary Get table by id
   * @param {TableReadReq} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public tableReadPOST(body: TableReadReq, options?: any) {
    return DefaultApiFp(this.configuration).tableReadPOST(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Update table properties and associated columns by ID
   * @summary Update table by ID
   * @param {TableUpdateReq} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public tableUpdatePOST(body: TableUpdateReq, options?: any) {
    return DefaultApiFp(this.configuration).tableUpdatePOST(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   * Retrieve all tables with pagination and search
   * @summary Get all tables
   * @param {ReadPaginationFilter} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public tablesReadPOST(body: ReadPaginationFilter, options?: any) {
    return DefaultApiFp(this.configuration).tablesReadPOST(body, options)(
      this.fetch,
      this.basePath,
    );
  }
}
